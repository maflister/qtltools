<html>
<head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-176212697-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-176212697-1');
</script>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1"/>
<meta http-equiv="Cache-Control" content="max-age=3600"/>
<meta name="description" content="description"/>
<meta name="keywords" content="keywords"/> 
<meta name="author" content="author"/> 
<link rel="stylesheet" type="text/css" href="../style/default.css" media="screen"/>
<title>QTLtools</title>
<script language="Javascript" src="../script/print_last_modif_date.js" ></script>
</head>

<body>
<div class="content">
	<div class="item"  id="item2">
	<p style="font-size:18px"> <b>This page is outdated, please also see the man page. </b></p>
	</div>
	<div class="item"  id="item1">
		<h1>How to run fenrich?</h1>
		<p>
		This mode allows assessing a set of QTLs fall within some functional annotations more often than what is expected by chance.
		To illustrate how it works, first download the required example data:
		</p>

		<ul>
			<li> The results from a full cis-analysis: <a href="http://jungle.unige.ch/QTLtools_examples/results.genes.full.txt.gz" download>TXT</a></li>
			<li> The functional annotation for few Transcription Factor Binding sites: <a href="http://jungle.unige.ch/QTLtools_examples/TFs.encode.bed.gz" download>BED</a></li>
		</ul>

		<br>
		<h3>Step1: Prepare the QTL data</h3>
		<p>
		First, you need to prepare a BED file containing the positions of the QTLs of interest. To do so, extract all significant hits at a given FDR threshold (e.g. 5%):		
		</p>

		<code>
		Rscript ./script/runFDR_cis.R results.genes.full.txt.gz 0.05 results.genes
		</code>

		<p>
		Then, transform the significant QTL list into a BED file using the following command:
		</p>

		<code>
		cat results.genes.significant.txt | awk '{ print $9, $10-1, $11, $8, $1, $5 }'  | tr " " "\t" | sort -k1,1 -k2,2n > results.genes.significant.bed
		</code>

		<p>
		The resulting BED file looks like this:
		</p>
		
		<code>
		head results.genes.significant.bed<br>
		1	15210	15211	1_15211	ENSG00000227232.4	-<br>
		1	735984	735985	1_735985	ENSG00000177757.1	+<br>
		1	735984	735985	1_735985	ENSG00000240453.1	-<br>
		1	739527	739528	1_739528	ENSG00000237491.4	+<br>
		1	754963	754964	1_754964	ENSG00000225880.4	-<br>
		1	769222	769223	1_769223	ENSG00000228794.4	+<br>
		1	832397	832398	1_832398	ENSG00000230699.2	+<br>
		1	844342	844343	1_844343	ENSG00000223764.2	-<br>
		1	879675	879676	1_879676	ENSG00000187634.6	+<br>
		1	895705	895706	1_895706	ENSG00000187961.9	+
		</code>

		<p>
		Note here that this file contains the follwing columns:
		</p>

		<ul>
			<li>1. Chromosome ID</li>
			<li>2. Start position of the QTL</li>
			<li>3. End position of the QTL</li>
			<li>4. QTL ID</li>
			<li>5. Targeted phenotype ID (crucial here, specify well the phenotype so that distance between QTL and phenotype can be determined)</li>
			<li>6. Strand orientation (not used, can be whatever you want)</li>	
		</ul>

		<br>
		<h3>Step2: Prepare the Phenotype data</h3>
		<p>
		Then, you need to prepare a BED file containing the positions of all Phenotypes you mapped QTLs for.
		To do so, run this command on the raw QTL mapping output:		
		</p>

		<code>
		zcat results.genes.full.txt.gz | awk '{ print $2, $3-1, $4, $1, $8, $5 }'  | tr " " "\t" | sort -k1,1 -k2,2n > results.genes.quantified.bed
		</code>

		<p>
		The resulting BED file looks like this:
		</p>
		
		<code>
		head results.genes.quantified.bed<br>
		1	29369	29370	ENSG00000227232.4	1_15211	-<br>
		1	135894	135895	ENSG00000268903.1	1_985446	-<br>
		1	137964	137965	ENSG00000269981.1	1_1118728	-<br>
		1	139378	139379	ENSG00000237683.5	1_965604	-<br>
		1	267252	267253	ENSG00000228463.4	1_256498	-<br>
		1	317719	317720	ENSG00000237094.7	1_15211	+<br>
		1	564441	564442	ENSG00000225972.1	1_1079866	+<br>
		1	565019	565020	ENSG00000225630.1	1_1077962	+<br>
		1	566453	566454	ENSG00000237973.1	1_69428	+<br>
		1	568136	568137	ENSG00000229344.1	1_1392271	+
		</code>

		<p>
		This file contains the follwing columns:
		</p>

		<ul>
			<li>1. Chromosome ID of the phenotype</li>
			<li>2. Start position of the phenotype</li>
			<li>3. End position of the phenotype</li>
			<li>4. Phenotype ID</li>
			<li>5. Top variants (not used, can be whatever you want)</li>
			<li>6. Strand orientation (important to measure distance between QTLs and phenotypes)</li>	
		</ul>

		<br>
		<h3>Step3: Run the enrichment measurements</h3>
		<p>
		Now that you've got your QTL and phenotype file ready to go, you can then measure the enrichement using the following command:
		</p>

		<code>
		QTLtools fenrich --qtl results.genes.significant.bed --tss results.genes.quantified.bed --bed TFs.encode.bed.gz --out enrichement.QTL.in.TF.txt
		</code>

		<p>
		This generates a file <i>enrichement.QTL.in.TF.txt</i> that contains the number of functional annotations per 1kb bins around QTLs.
		</p>
		
		<code>
		cat enrichement.QTL.in.TF.txt<br> 
		1088 10762 711.253 23.1664 0.000999001 1.7049 1.58987 1.48432
		</code>

		<ul>
			<li>1. <b>observed</b> number of QTLs falling within the functional annotations</li>
			<li>2. total number of QTLs</li>
			<li>3. mean <b>expected</b> number of QTLs falling within the functional annotations (across multiple permutations, see below)</li>
			<li>4. standard deviation of the <b>expected</b> number of QTLs falling within the functional annotations (across multiple permutations, see below)</li>
			<li>5-8. dummy fields</li>
		</ul>

		<p>
		You can use the following option to tune the calculations:
		</p>

		<ul>
			<li><i>--permute [int]</i>: number of permutations of the functional landscape done to get expectations (default is 1000)</li>
		</ul>

		<p>
		Once you've got your observation and expectation, you can measure the enrichment related statistics in R using:
		</p>

		<code>
		R> D=read.table("enrichement.QTL.in.TF.txt", head=FALSE, stringsAsFactors=FALSE)<br>
		R> fisher.test(matrix(c(D$V1, D$V2, round(D$V3), D$V2), ncol=2))<br>
		R= Fisher's Exact Test for Count Data<br>
		R= data:  matrix(c(D$V1, D$V2, round(D$V3), D$V2), ncol = 2)<br>
		R= p-value < 2.2e-16<br>
		R= alternative hypothesis: true odds ratio is not equal to 1<br>
		R= 95 percent confidence interval:<br>
		R= 1.385641 1.690700<br>
		R= sample estimates:<br>
		R= odds ratio <br>
		R= 1.5302
		</code>

		<p>
		So the enrichment has an odd ration of ~1.53 with a significant P-value < 2.2e-16.
		</p>
	</div>
	
	<div class="log">Monday 11th July 2016</div>
</div>
</body>
</html>
